<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
        }
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="lib/three.js"></script>
</head>
<body>
    <div id="container"></div>
    <script src="lib/three-109/three.min.js"></script>
    <script src="lib/three-109/OrbitControls.js"></script>
    <script>
        function init() {
            var container = document.getElementById('container');
            var width = window.innerWidth;
            var height = window.innerHeight;

            // init renderer
            var renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuff: true
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0xffffff, 1.0);
            container.appendChild(renderer.domElement);

            // init scene
            var scene = new THREE.Scene();
            var bgTexture = new THREE.ImageUtils.loadTexture('img/bg.jpg');
            scene.background = bgTexture;

            // init camera
            var camera = new THREE.PerspectiveCamera(50, width / height, 1, 2000);
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 400;

            camera.up.x = 0;
            camera.up.y = 1;
            camera.up.z = 0;
            camera.lookAt(0, 0, 0);

            // init controls
            var orbitControl = new THREE.OrbitControls(camera, renderer.domElement);
//            orbitControl.minDistrance = 20;
//            orbitControl.maxDistrance = 50;
            orbitControl.maxPolarAngle = Math.PI / 2;

            // init objects
            var group = new THREE.Group();
            scene.add(group);

            // start render
            globe(group);
            render()

            function render() {
                requestAnimationFrame(render);
                group.rotation.y -= 0.0005;
                renderer.render(scene, camera);
            }

            function globe(group) {
                // add earth
                var texture = THREE.ImageUtils.loadTexture('textures/earth-map.jpg');
                var geometry = new THREE.SphereGeometry(100, 100, 100);
                var material = new THREE.MeshStandardMaterial({ map: texture });
                var earth = new THREE.Mesh(geometry, material);
                group.add(earth);
                group.rotation.x = THREE.Math.degToRad(35);
                group.rotation.y = THREE.Math.degToRad(170);

                // add light
                var light = new THREE.HemisphereLight(0xffffff, 0x333333, 2);
                light.position.x = 0;
                light.position.y = 0;
                light.position.z = -200;
                group.add(light);

                // add stars
                var starsGeometry = new THREE.Geometry();
                for (var i = 0; i < 2000; i++) {
                    var starVector = new THREE.Vector3(
                        THREE.Math.randFloatSpread(2000),
                        THREE.Math.randFloatSpread(2000),
                        THREE.Math.randFloatSpread(2000)
                    );
                    starsGeometry.vertices.push(starVector);
                }
                var starMaterial = new THREE.PointsMaterial({ color: 0x888888 });
                var stars = new THREE.Points(starsGeometry, starMaterial);
                group.add(stars);

                // add planes
                var planeMarkers = {};

                function addPlane(item) {
                    var planeShape = new THREE.Shape();
                    planeShape.moveTo(0, 0);
                    planeShape.lineTo(0.2, -0.2);
                    planeShape.lineTo(0.2, -1.3);
                    planeShape.lineTo(1.6, -2.7);
                    planeShape.lineTo(1.6, -3);
                    planeShape.lineTo(0.2, -2.1);
                    planeShape.lineTo(0.2, -3);
                    planeShape.lineTo(0.5, -3.4);
                    planeShape.lineTo(0.5, -3.7);
                    planeShape.lineTo(0, -3.3);
                    planeShape.lineTo(-0.5, -3.7);
                    planeShape.lineTo(-0.5, -3.4);
                    planeShape.lineTo(-0.2, -3);
                    planeShape.lineTo(-0.2, -2.1);
                    planeShape.lineTo(-1.6,-3);
                    planeShape.lineTo(-1.6,-2.7);
                    planeShape.lineTo(-0.2, -1.3);
                    planeShape.lineTo(-0.2, -0.2);
                    var planeGeometry = new THREE.ShapeGeometry(planeShape);
                    var planeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x9fb4dd,
                        side: THREE.DoubleSide,
                        depthTest: true
                    });

                    if (item.anum && item.lng && item.lat) {
                        var plane = new THREE.Mesh(planeGeometry, planeMaterial)
                        plane.rotation.z = THREE.Math.degToRad(item.ang);
                        var position = getPosition(item.lng, item.lat, 5);
                        plane.position.set(position.x, position.y, position.z);

                        planeMarkers[item.anum] = plane;
                        group.add(plane);
                        drawHistoryTrack(item.anum);
                    }
                }
                function drawHistoryTrack(anum) {}
                function getPosition(lng, lat, alt) {
                    var phi = (90 - lat) * (Math.PI / 180);
                    var theta = (lng + 180) * (Math.PI / 180);
                    var radius = alt + 200;
                    var x = -(radius * Math.sin(phi)) * Math.cos(theta);
                    var y = (radius * Math.sin(phi)) * Math.sin(theta);
                    var z = (radius * Math.sin(phi));
                    return { x: x, y: y, z: z }
                }

            }

            window.addEventListener('resize', onResize, false);
            function onResize() {
                width = window.innerWidth;
                height = window.innerHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                renderer.setSize(width, height);
            }
        }

        window.onload = init;
    </script>
</body>
</html>